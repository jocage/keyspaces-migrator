import { Client } from 'cassandra-driver';
import * as fs from 'fs';
import { Logger } from './logger';
import { TableColumn, TableSchema, TypeGenerationConfig } from './types';

const logger = Logger.getInstance();

export class TypeGenerator {
  private client: Client;
  private keyspace: string;
  private outputFile: string;
  private includeComments: boolean;

  constructor(config: TypeGenerationConfig) {
    this.client = config.client;
    this.keyspace = config.keyspace;
    this.outputFile = config.outputFile;
    this.includeComments = config.includeComments || true;
  }

  /**
   * Generate TypeScript types for all tables in the keyspace
   */
  async generateTypes(): Promise<void> {
    logger.info(`Generating types for keyspace: ${this.keyspace}`);

    try {
      const tables = await this.getTableSchemas();
      const typeDefinitions = this.generateTypeDefinitions(tables);

      fs.writeFileSync(this.outputFile, typeDefinitions);
      logger.success(`Types generated successfully: ${this.outputFile}`);
    } catch (error) {
      logger.error(`Failed to generate types: ${error}`);
      throw error;
    }
  }

  /**
   * Get schema information for all tables in the keyspace
   */
  private async getTableSchemas(): Promise<TableSchema[]> {
    const tablesQuery = `
      SELECT table_name 
      FROM system_schema.tables 
      WHERE keyspace_name = ?
    `;

    const columnsQuery = `
      SELECT column_name, type, kind, position
      FROM system_schema.columns 
      WHERE keyspace_name = ? AND table_name = ?
      ORDER BY position
    `;

    try {
      const tablesResult = await this.client.execute(tablesQuery, [
        this.keyspace,
      ]);
      const tableNames = tablesResult.rows.map(row => row.table_name);

      const schemas: TableSchema[] = [];

      for (const tableName of tableNames) {
        const columnsResult = await this.client.execute(columnsQuery, [
          this.keyspace,
          tableName,
        ]);

        const columns: TableColumn[] = columnsResult.rows.map(row => ({
          columnName: row.column_name,
          type: row.type,
          kind: row.kind,
          position: row.position,
        }));

        schemas.push({
          keyspaceName: this.keyspace,
          tableName,
          columns,
        });
      }

      logger.debug(
        `Found ${schemas.length} tables in keyspace ${this.keyspace}`
      );
      return schemas;
    } catch (error) {
      throw new Error(`Failed to get table schemas: ${error}`);
    }
  }

  /**
   * Generate TypeScript type definitions from table schemas
   */
  private generateTypeDefinitions(tables: TableSchema[]): string {
    const header = this.generateHeader();
    const typeDefinitions = tables
      .map(table => this.generateTableType(table))
      .join('\n\n');
    const tableNamesType = this.generateTableNamesType(tables);
    const exports = this.generateExports(tables);

    return [header, typeDefinitions, tableNamesType, exports].join('\n\n');
  }

  /**
   * Generate file header with comments and imports
   */
  private generateHeader(): string {
    const timestamp = new Date().toISOString();

    return `/**
 * Auto-generated TypeScript types for AWS Keyspaces
 * Keyspace: ${this.keyspace}
 * Generated: ${timestamp}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Run 'npx keyspaces-migrator generate-types' to regenerate
 */

// Common Cassandra/Keyspaces types
export type CassandraUUID = string;
export type CassandraTimestamp = Date;
export type CassandraDate = Date;
export type CassandraTime = string;
export type CassandraDecimal = number;
export type CassandraVarint = number;
export type CassandraBigint = string;
export type CassandraBlob = Buffer;
export type CassandraInet = string;`;
  }

  /**
   * Generate TypeScript interface for a single table
   */
  private generateTableType(table: TableSchema): string {
    const interfaceName = this.toPascalCase(table.tableName);
    const columns = table.columns.map(col => this.generateColumnType(col));

    let result = '';

    if (this.includeComments) {
      result += `/**\n * Table: ${table.tableName}\n`;

      const partitionKeys = table.columns.filter(
        col => col.kind === 'partition_key'
      );
      const clusteringKeys = table.columns.filter(
        col => col.kind === 'clustering'
      );

      if (partitionKeys.length > 0) {
        result += ` * Partition Keys: ${partitionKeys
          .map(col => col.columnName)
          .join(', ')}\n`;
      }

      if (clusteringKeys.length > 0) {
        result += ` * Clustering Keys: ${clusteringKeys
          .map(col => col.columnName)
          .join(', ')}\n`;
      }

      result += ` */\n`;
    }

    result += `export interface ${interfaceName} {\n`;
    result += columns.map(col => `  ${col}`).join('\n');
    result += '\n}';

    return result;
  }

  /**
   * Generate TypeScript property for a table column
   */
  private generateColumnType(column: TableColumn): string {
    const tsType = this.mapCassandraTypeToTypeScript(column.type);
    const optional =
      column.kind === 'regular' || column.kind === 'static' ? '?' : '';

    let result = `${column.columnName}${optional}: ${tsType};`;

    if (this.includeComments) {
      const kindComment =
        column.kind === 'partition_key'
          ? ' // Partition Key'
          : column.kind === 'clustering'
          ? ' // Clustering Key'
          : column.kind === 'static'
          ? ' // Static Column'
          : '';
      result += kindComment;
    }

    return result;
  }

  /**
   * Map Cassandra/CQL data types to TypeScript types
   */
  private mapCassandraTypeToTypeScript(cassandraType: string): string {
    const typeMap: Record<string, string> = {
      // Text types
      text: 'string',
      varchar: 'string',
      ascii: 'string',

      // Numeric types
      int: 'number',
      bigint: 'CassandraBigint',
      smallint: 'number',
      tinyint: 'number',
      varint: 'CassandraVarint',
      float: 'number',
      double: 'number',
      decimal: 'CassandraDecimal',

      // Boolean
      boolean: 'boolean',

      // UUID
      uuid: 'CassandraUUID',
      timeuuid: 'CassandraUUID',

      // Date/Time
      timestamp: 'CassandraTimestamp',
      date: 'CassandraDate',
      time: 'CassandraTime',

      // Binary
      blob: 'CassandraBlob',

      // Network
      inet: 'CassandraInet',
    };

    // Handle collection types
    if (cassandraType.startsWith('list<')) {
      const innerType = cassandraType.slice(5, -1);
      return `Array<${this.mapCassandraTypeToTypeScript(innerType)}>`;
    }

    if (cassandraType.startsWith('set<')) {
      const innerType = cassandraType.slice(4, -1);
      return `Set<${this.mapCassandraTypeToTypeScript(innerType)}>`;
    }

    if (cassandraType.startsWith('map<')) {
      const match = cassandraType.match(/map<(.+),\s*(.+)>/);
      if (match) {
        const keyType = this.mapCassandraTypeToTypeScript(match[1]);
        const valueType = this.mapCassandraTypeToTypeScript(match[2]);
        return `Map<${keyType}, ${valueType}>`;
      }
    }

    return typeMap[cassandraType.toLowerCase()] || 'any';
  }

  /**
   * Generate a union type of all table names
   */
  private generateTableNamesType(tables: TableSchema[]): string {
    const tableNames = tables.map(table => `'${table.tableName}'`).join(' | ');

    return `// Union type of all table names
export type TableName = ${tableNames};`;
  }

  /**
   * Generate exports section
   */
  private generateExports(tables: TableSchema[]): string {
    const interfaces = tables.map(table => this.toPascalCase(table.tableName));

    return `// Re-export all interfaces
export type {
  ${interfaces.join(',\n  ')}
};

// Table name to interface mapping
export type TableTypeMap = {
  ${tables
    .map(table => `'${table.tableName}': ${this.toPascalCase(table.tableName)}`)
    .join(';\n  ')};
};`;
  }

  /**
   * Convert snake_case to PascalCase
   */
  private toPascalCase(str: string): string {
    return str
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}
